package st

import (
	"iter"
	"slices"
)

// This is a stater structure, used to drive the creation of new OverlappingSpanSets.
// Each source of spans should have their own instance of SpanOverlapAccumulator.
type SpanOverlapAccumulator[E any] struct {
	Rss *OverlappingSpanSets[E]
	*SpanUtil[E]
	// When true slices passed in will be sorted.
	Sort bool

	// When not nil, this object has encounter an error
	Err error

	// Sequence counter
	Pos int

	// Turns validation on/off, default false or off
	Validate bool

	// Turns consolidation of adjacent spans on or off, default false or off
	Consolidate bool
}

// The Accumulate method.
//
// For a given span provided:
// When the span overlaps with the current internal span, the OverlappingSpanSets is expanded and the span is append to the Contains slice.
// When the span is outside of the current internal span, then a new OverlappingSpanSets is created with this span as its current span.
func (s *SpanOverlapAccumulator[E]) Accumulate(span SpanBoundry[E]) *OverlappingSpanSets[E] {
	s.Pos++
	if s.Validate {
		s.Err = s.Check(span, s.Rss.Span)
	}

	if s.Rss.Span == nil {
		s.Rss.Span = span
		return s.Rss
	}

	a := s.Rss.Span
	if s.Cmp(a.GetEnd(), span.GetBegin()) < 0 {
		var joined = false
		if s.Consolidate {
			var next = s.Next(a.GetEnd())
			if s.Cmp(next, span.GetBegin()) == 0 {
				s.Rss.Span = &Span[E]{
					Begin: a.GetBegin(),
					End:   span.GetEnd(),
				}
				joined = true
			}
		}
		if !joined {

			s.Rss = &OverlappingSpanSets[E]{
				Span:     span,
				Contains: nil,
				SrcBegin: s.Pos,
				SrcEnd:   s.Pos,
			}
		}
	} else {
		x, y := s.ContainedBy(a, span)
		if x|y != 0 {
			var r = Span[E]{}
			if x < 0 {
				r.Begin = a.GetBegin()
			} else {
				r.Begin = span.GetBegin()
			}
			if y > 0 {
				r.End = a.GetEnd()
			} else {
				r.End = span.GetEnd()
			}
			s.Rss.Span = &r
		}

		if s.Rss.Contains == nil {
			s.Rss.Contains = &[]SpanBoundry[E]{a, span}
		} else {
			*s.Rss.Contains = append(*s.Rss.Contains, span)
		}
		s.Rss.SrcEnd = s.Pos
	}
	return s.Rss
}

// Creates a channel iterator for chan of OverlappingSpanSets.
func (s *SpanOverlapAccumulator[E]) ChanIterFactoryOverlaps(c <-chan *OverlappingSpanSets[E]) iter.Seq2[int, *OverlappingSpanSets[E]] {

	if c == nil {
		return func(yeild func(int, *OverlappingSpanSets[E]) bool) {
		}
	}
	var i = 0
	return func(yeild func(int, *OverlappingSpanSets[E]) bool) {
		var ol, ok = <-c
		for ok {

			if !yeild(i, ol) {
				return
			}
			i++
			ol, ok = <-c
		}

	}
}

// Helper function to create an overlap iterator from a slice of list.
func (s *SpanOverlapAccumulator[E]) SliceIterFactoryOverlaps(list *[]*OverlappingSpanSets[E]) iter.Seq2[int, *OverlappingSpanSets[E]] {

	if list == nil {
		return func(yeild func(int, *OverlappingSpanSets[E]) bool) {
		}
	}
	var end = len(*list)
	var i = 0
	return func(yeild func(int, *OverlappingSpanSets[E]) bool) {
		for ; i < end; i++ {
			if !yeild(i, (*list)[i]) {
				return
			}
		}
	}
}

// Generates a iter.Seq2 iterator, for a channel of SpanBoundry instances.
func (s *SpanOverlapAccumulator[E]) ChanIterFactory(c <-chan SpanBoundry[E]) iter.Seq2[int, *OverlappingSpanSets[E]] {
	var sa = s.SpanStatefulAccumulator()
	if c != nil {
		var span, ok = <-c
		for ok {
			if sa.SetNext(span) {
				break
			}
			span, ok = <-c
		}
	}
	return func(yeild func(int, *OverlappingSpanSets[E]) bool) {
		// no chan??? stop here
		if !sa.HasNext() {
			return
		}

		for {
			if s.Err != nil {
				return
			}
			if sa.HasNext() {
				var id, current = sa.GetNext()
				if !yeild(id, current) {
					return
				}
				var span, ok = <-c
				for ok {
					if sa.SetNext(span) {
						break
					}
					span, ok = <-c
				}
			} else {
				return
			}
		}
	}
}

func (s *SpanOverlapAccumulator[E]) SpanStatefulAccumulator() *SpanIterSeq2Stater[E] {
	var si = &SpanIterSeq2Stater[E]{
		Sa:      s,
		Current: nil,
		Next:    nil,
		Id:      -1,
	}
	return si
}

// Factory interface for converting slices of SpanBoundaries instances into iterator sequences of OverlappingSpanSets.
func (s *SpanOverlapAccumulator[E]) SliceIterFactory(list *[]SpanBoundry[E]) iter.Seq2[int, *OverlappingSpanSets[E]] {
	var end = -1
	var pos = 0
	var au = s.SpanStatefulAccumulator()
	if list != nil {
		if s.Sort {
			slices.SortFunc(*list, s.Compare)
		}
		end = len(*list)
		for pos < end {
			if au.SetNext((*list)[pos]) {
				pos++
				break
			}
			pos++
		}
	}

	return func(yeild func(int, *OverlappingSpanSets[E]) bool) {
		// no list stop here
		if end == -1 {
			return
		}

		for {
			if s.Err != nil {
				return
			}
			if au.HasNext() {
				var id, current = au.GetNext()

				if !yeild(id, current) {
					return
				}
				for pos < end {
					if au.SetNext((*list)[pos]) {
						pos++
						break
					}
					pos++
				}
			} else {
				return
			}

		}
	}
}

// This is a convenience method for initializing the iter.Seq2 stater internals based on a slice of SpanBoundry.
func (s *SpanOverlapAccumulator[E]) ColumnOverlapSliceFactory(list *[]SpanBoundry[E]) *ColumnOverlapAccumulator[E] {
	return s.ColumnOverlapFactory(s.SliceIterFactory(list))
}

func (s *SpanOverlapAccumulator[E]) ColumnChanOverlapSpanSetsFactory(c <-chan *OverlappingSpanSets[E]) *ColumnOverlapAccumulator[E] {
	return s.SpanUtil.ColumnOverlapFactory(s.ChanIterFactoryOverlaps(c))
}
